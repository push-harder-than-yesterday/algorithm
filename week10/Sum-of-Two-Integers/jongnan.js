/*
풀이 방법
----------------------------------------------------
비트 연산자를 사용

처음에는 2진수로 변경한 다음 자리수 마다 덧셈을
이용하여 하나하나 해줄려고 했지만 -가 문제
2의 보수를 취해 덧셈을 해주려했지만 이 보다 더 좋은
방법이 존재할 것이라는 생각에 검색
역시 존재 했었음....

방법은 다음과 같다.
1. 두 수를 XOR 연산 --> sum
2. 두 수를 AND 연산 한 뒤 좌 쉬프트 --> carry
3. 만약 carry가 0이라면 sum 반환
4.      carry가 0이 아니라면 sum, carry를 
        다시한번 같은 과정을 거침

예시를 보자.
15 + 14
sum   = 1111(2) ^ 1110(2) = 0001(2)
carry = 1111(2) & 1110(2) = 1110(2) << 1 = 11100(2)

여기서 캐리를 좌쉬프트 해주는 이유는
캐리는 윗 자리수에 덧셈을 해줘야 하는 것이므로
좌시프트를 통해 자리수를 늘려주고 적용
만약 캐리가 0이라면 추가적으로 더할 필요가 없으므로 종료

덧셈은 OR 연산자를 사용하지 않는 이유는
같은 자리수에 1 1이라면 0이 나와야하는 상황
OR의 경우 1이 나오므로 적절하지 않음

위 예시에서 carry가 0이 아니므로 다시 한번 연산

0001(2) + 11100(2)
sum   = 0001(2) ^ 11100(2) = 11101(2)
carry = 0001(2) & 11100(2) = 00000(2)

carry가 0이므로 종료

*/
var getSum = function (a, b) {
	let sum = a;
	let carry = b;
	while (carry !== 0) {
		const temp = sum;
		sum = sum ^ carry;
		carry = (temp & carry) << 1;
	}
	return sum;
};
